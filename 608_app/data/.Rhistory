print((B%^%n) %*% r)
```
Compute the eigen-decomposition of B and verify that you indeed get an eigenvalue
of 1 as the largest eigenvalue and that its corresponding eigenvector is the same
vector that you obtained in the previous power iteration method. Further, this
eigenvector has all positive entries and it sums to 1.
```{r}
e <- eigen(B)
v <- e$vec[,1]
v <- as.numeric(v) / sum(as.numeric(v))
v
```
Use the graph package in R and its page.rank method to compute the Page Rank
of the graph as given in A. Note that you don't need to apply decay. The package
starts with a connected graph and applies decay internally. Verify that you do get
the same PageRank vector as the two approaches above.
```{r}
# will create the graph but wil first name the nodes
# Will use the orginal matrix as the graph package applies the decay internally
#rownames(A) = c("A", "B", "c","D", "E","F")
g  <- graph.adjacency(t(A),weighted=TRUE)
plot(g,layout=layout.fruchterman.reingold,edge.width=E(g)$weight/2)
page.rank(g)$vector
```
e
v
e$values
e$values[1]
max(unlist(e$values))
max(unlist(e$values, recursive = TRUE))
w = e$values
w
unlist(w)
w[1]
w[2]
w[]
unlist(w[])
max(w[])
max(unlist(w[]))
max(unlist(w))
class(w)
max(as.numerica(w))
max(as.numeric(w))
print (paste('Largest eigenvalue is: ', max(as.numeric(e$value)))
print (paste('Largest eigenvalue is: ', max(as.numeric(e$value))))
print (paste('Largest eigenvalue is: ', max(as.numeric(e$value))))
print(paste("Sum of eigenvector for largest eigenvalue is: ", sum(as.numeric(v))))
v <- e$vec[,1]
v
---
title: "Assignment 10"
author: "Adejare Windokun"
date: "Thursday, April 02, 2015"
output: pdf_document
---
ASSIGNMENT 10 - PAGE RANK
Loading required packages, expm for exponential function for matrices
and the igraph package to use the pagerank algorithm
```{r}
#install.packages("expm")
library(expm)
#install.packages("igraph")
library(igraph)
```
Form the A matrix. Then, introduce decay and form the B matrix as we did in
the course notes.
```{r}
A <- rbind(c(0,   0,    1/4,   0,   0,   0),
c(1/2, 0,    1/4,   0,   0,   0),
c(1/2, 1,    0,     0,   0,   1/2),
c(0,   0,    0,     0,   1/2, 1/2),
c(0,   0,    1/4,   1/2, 0,   0),
c(0,   0,    1/4,   1/2, 1/2,   0))
A
# Introducting  decay and form the B matrix
n = nrow(A)
beta <- 0.85
# This is another way of performing the calucalion which is create the Matrix
# U containing r multiplied by the 1-beta and adding that to the A matrix
# U = matrix(A=rep(1/n, n^2), nrow=n, ncol=n)
# B = beta*A+(1-beta)*U
# Per course Notes
B <- A * beta + (1-beta)/n
```
Start with a uniform rank vector r and perform power iterations on B till conver-
gence. That is, compute the solution r = Bn^r. Attempt this for a sufficiently
large n so that r actually converges.
```{r}
# uniform rank vector r
n <- nrow(A)
r <- cbind(rep(1/n, n))
n <- 1
# At convergence B^(n+1)r = B^nr
while (!all(B%^%(n+1) %*% r == (B%^%n) %*% r)){
n <- n+1
#print(n)
# print (B%^%(n+1))
}
print (paste('Number of iterations = ', n))
print ('Page Rank Vector for A is:')
print((B%^%n) %*% r)
```
Compute the eigen-decomposition of B and verify that you indeed get an eigenvalue
of 1 as the largest eigenvalue and that its corresponding eigenvector is the same
vector that you obtained in the previous power iteration method. Further, this
eigenvector has all positive entries and it sums to 1.
```{r}
e <- eigen(B)
print (paste('Largest eigenvalue is: ', max(as.numeric(e$value))))
v <- e$vec[,1]
v <- as.numeric(v) / sum(as.numeric(v))
print(paste("Sum of eigenvector for largest eigenvalue is: ", sum(as.numeric(v))))
v
```
Use the graph package in R and its page.rank method to compute the Page Rank
of the graph as given in A. Note that you don't need to apply decay. The package
starts with a connected graph and applies decay internally. Verify that you do get
the same PageRank vector as the two approaches above.
```{r}
# will create the graph but wil first name the nodes
# Will use the orginal matrix as the graph package applies the decay internally
#rownames(A) = c("A", "B", "c","D", "E","F")
g  <- graph.adjacency(t(A),weighted=TRUE)
plot(g,layout=layout.fruchterman.reingold,edge.width=E(g)$weight/2)
page.rank(g)$vector
```
Summary
```{r}
print('Pagerank of A using Matrix computation: ')
((B%^%n) %*% r)
print('Pagerank of A using eigen-decomposition: ')
v
print('Pagerank of A using graph of A: ')
page.rank(g)$vector
```
2**3
h = 1 e**10
h = .0000001
x= 2
3x
3*x
myDerivative = function(x){
# f(x) = x**3 + x**2
# let h be a very small increment of x
# therefore the slope of the line segment for f(x), for x = (x, x+h),
# y = (f(x), f(x+h)) = f(x+h) -f(x)/(x+h -x)
# = f(x+h) -fx) /h
# = [(x+h)**3 +(x+h)**2 -x**3 - x**2]/h
# = [x**3 =3hx**2 +3hx**2 +h**3 +x**2 +2hx +h**2 -x**3 -x**2]/h
# = [3hx**2 +3xh**2 +2hx +h**3 +h**2]/h
# = 3x**2 +3hx + 2x + h**2 +h
# As h -> 0, this becomes 3x**2 + 2x
# However of this problem will not use the derivative but will use very small
# values of h
h = 1e -6
return (3*(x**2) + 3*h*x + 2*x + (h**2) + h)
}
myDerivative = function(x){
# f(x) = x**3 + x**2
# let h be a very small increment of x
# therefore the slope of the line segment for f(x), for x = (x, x+h),
# y = (f(x), f(x+h)) = f(x+h) -f(x)/(x+h -x)
# = f(x+h) -fx) /h
# = [(x+h)**3 +(x+h)**2 -x**3 - x**2]/h
# = [x**3 =3hx**2 +3hx**2 +h**3 +x**2 +2hx +h**2 -x**3 -x**2]/h
# = [3hx**2 +3xh**2 +2hx +h**3 +h**2]/h
# = 3x**2 +3hx + 2x + h**2 +h
# As h -> 0, this becomes 3x**2 + 2x
# However of this problem will not use the derivative but will use very small
# values of h
h = 1e -6
return (3*(x**2) + 3*h*x + 2*x + (h**2) + h))
}
h = 1e-6
return (3*(x**2) + 3*h*x + 2*x + (h**2) + h))
return (3 * (x**2) + 3 * h * x + 2 * x + (h**2) + h)
myDerivative = function(x){
# f(x) = x**3 + x**2
# let h be a very small increment of x
# therefore the slope of the line segment for f(x), for x = (x, x+h),
# y = (f(x), f(x+h)) = f(x+h) -f(x)/(x+h -x)
# = f(x+h) -fx) /h
# = [(x+h)**3 +(x+h)**2 -x**3 - x**2]/h
# = [x**3 =3hx**2 +3hx**2 +h**3 +x**2 +2hx +h**2 -x**3 -x**2]/h
# = [3hx**2 +3xh**2 +2hx +h**3 +h**2]/h
# = 3x**2 +3hx + 2x + h**2 +h
# As h -> 0, this becomes 3x**2 + 2x
# However of this problem will not use the derivative but will use very small
# values of h
h = 1e-6
return (3 * (x**2) + 3 * h * x + 2 * x + (h**2) + h)
}
myDerivative(3)
myDerivative = function(x){
# f(x) = x**3 + x**2
# let h be a very small increment of x
# therefore the slope of the line segment for f(x), for x = (x, x+h),
# y = (f(x), f(x+h)) = f(x+h) -f(x)/(x+h -x)
# = f(x+h) -fx) /h
# = [(x+h)**3 +(x+h)**2 -x**3 - x**2]/h
# = [x**3 =3hx**2 +3hx**2 +h**3 +x**2 +2hx +h**2 -x**3 -x**2]/h
# = [3hx**2 +3xh**2 +2hx +h**3 +h**2]/h
# = 3x**2 +3hx + 2x + h**2 +h
# As h -> 0, this becomes 3x**2 + 2x
# However of this problem will not use the derivative but will use very small
# values of h
h = 1e-10
return (3 * (x**2) + 3 * h * x + 2 * x + (h**2) + h)
}
myDerivative(3)
n = (3-1)/1e-06
n
smallinterval = 1e-06
n = (3-1)/smallinterval
smallinterval = 1e-06
n = (3-1)/smallinterval
# the area under the curve 3x^2 + 4x will be equal to the sum of the rectanges
# in the range x = (1,3), with the base of the rectange being 1e-06, the number
# of rectangles being n, while the height will taken as the left side height of
# trapezium
# Psuedo code
# the sum of the rectangles will be the sum of the sides mutipled by the base
# for (i in n, by = 1e-6)
# len = len + f(i-1e-6)
# area = len * 1e-6
len = 0
for (i in n, by = smallinterval){
len = len + i
}
len = 0
for (i in 1:n, by = smallinterval){
len = len + i
}
len = 0
for (i in seq(1, n, smallinterval){
len = len + i
}
len = 0
for (i in seq(1, n, smallinterval){
len = len + i
}
len = 0
len = len + i
n = (3-1)/smallinterval
smallinterval = 1e-06
for (i in seq(1, n, smallinterval){
len = len + i
}
for(x in seq(1,100,5)) {
print(x)
}
for(x in seq(1,10,.5)) {
print(x)
}
for(i in seq(1,10,.5)) {
print(i)
}
smallinterval = 5
for(i in seq(1,10,smallinterval)) {
print(i)
}
len = 0
smallinterval = 5
for(i in seq(1,10,smallinterval)) {
len = len + i
}
print(len)
smallinterval = 5000
for(i in seq(1,10,smallinterval)) {
len = len + i
}
print(len)
len = 0
smallinterval = 50000
for(i in seq(1,10,smallinterval)) {
len = len + i
}
print(len)
len = 0
smallinterval = 5
for(i in seq(1,10,smallinterval)) {
len = len + i
}
print(len)
len = 0
smallinterval = 5
for(i in seq(1,10,smallinterval)) {
len = len + i
print len
}
print(len)
len = 0
smallinterval = 5
for(i in seq(1,10,smallinterval)) {
len = len + i
print (len)
}
print(len)
len = 0
smallinterval = 1
for(i in seq(1,10,smallinterval)) {
len = len + i
print (len)
}
print(len)
len = 0
smallinterval = 10
for(i in seq(1,3,smallinterval)) {
len = len + i
print (len)
}
print(len)
len = 0
smallinterval = 0.10
for(i in seq(1,3,smallinterval)) {
len = len + i
print (len)
}
print(len)
smallinterval = 0.10
for(i in seq(1,3,smallinterval)) {
print(i)
}
smallinterval = 0.010
for(i in seq(1,3,smallinterval)) {
print(i)
}
smallinterval = 0.010
for(i in seq(1,3,smallinterval)) {
# f(x)  = 3x^2 + 4x
print ( 3 * (i- smallinterval)**2 + 4*(i-smallinterval))
print(i)
}
len = 0
smallinterval = 0.010
for(i in seq(1,3,smallinterval)) {
# f(x)  = 3x^2 + 4x
len = len + ( 3 * (i- smallinterval)**2 + 4*(i-smallinterval))
print(len)
}
len = 0
smallinterval = 0.0010
for(i in seq(1,3,smallinterval)) {
# f(x)  = 3x^2 + 4x
len = len + ( 3 * (i- smallinterval)**2 + 4*(i-smallinterval))
print(len)
}
len = 0
smallinterval = 0.00010
for(i in seq(1,3,smallinterval)) {
# f(x)  = 3x^2 + 4x
len = len + ( 3 * (i- smallinterval)**2 + 4*(i-smallinterval))
print(len)
}
len = 0
smallinterval = 0.00010
for(i in seq(1,3,smallinterval)) {
# f(x)  = 3x^2 + 4x
len = len + ( 3 * (i- smallinterval)**2 + 4*(i-smallinterval))
print(len)
}
area = len*smallinterval
area
len = 0
smallinterval = 0.00010
for(i in seq(1,3,smallinterval)) {
# f(x)  = 3x^2 + 4x
len = len + ( 3 * (i)**2 + 4*(i))
print(len)
}
area = len*smallinterval
area
smallinterval = 1e-06
# Using the left side length of the trapezium
len = 0
for(i in seq(1,3,smallinterval)) {
# f(x)  = 3x^2 + 4x
# x = x - small increment
len = len + ( 3 * (i- smallinterval)**2 + 4*(i-smallinterval))
}
area = len*smallinterval
print("Area under the curve 3x^2 + 4x between x = (1, 3) using left side of the
trapezium:"
print(area)
print("Area under the curve 3x^2 + 4x between x = (1, 3) using left side of the
trapezium:")
print(area)
str = "Area under the curve 3x^2 + 4x between x = (1, 3) using left side of the"
print(str + " trapezium:")
print(area)
area = len*smallinterval
str = "Area under the curve 3x^2 + 4x between x = (1, 3) using left side of the"
print(paste(str, "trapezium:", sep = " ")
print(area)
print(paste(str, "trapezium:", sep = " ")
)3
area = len*smallinterval
str = "Area under the curve 3x^2 + 4x between x = (1, 3) using left side of the"
print(paste(str, "trapezium:", sep = " "))
print(area)
# Using the right side length of the trapezium
len = 0
for(i in seq(1,3,smallinterval)) {
# f(x)  = 3x^2 + 4x
len = len + ( 3 * (i)**2 + 4*(i))
}
area = len*smallinterval
str = "Area under the curve 3x^2 + 4x between x = (1, 3) using right side of the"
print(paste(str, "trapezium:", sep = " "))
print(area)
$$\int_0^{2\pi} \sin x~dx$$
$$\int_0^{2\pi} \sin x~dx$$
setwd("C:/Users/Jare_2/Desktop/WorkDocs/CUNY/608/Final Project/my_app - Copy")
shiny::runApp()
mppstate = cmsdata %>%
group_by(state) %>%
summarise(Total_Payment = sum(total_medicare_payment_amt), Count = n()) %>%
arrange(desc(Total_Payment))
saveloc = paste(getwd(), "/data/","cmsdata.RData", sep = "")
load(saveloc)
# convert datarame to tbl for easier manipulation
cmsdata = tbl_df(cmsdata)
mppstate = cmsdata %>%
group_by(state) %>%
summarise(Total_Payment = sum(total_medicare_payment_amt), Count = n()) %>%
arrange(desc(Total_Payment))
write.table(mppstate, file = paste(getwd(), "/data"/, "statecmsdata.csv", sep ="")
write.table(mppstate, file = paste(getwd(), "/data"/, "statecmsdata.csv", sep =""))
file = paste(getwd(), "/data"/, "statecmsdata.csv", sep ="")
write.table(mppstate, file = file )
file = paste(getwd(), "/data/", "statecmsdata.csv", sep ="")
write.table(mppstate, file = file )
file = paste(getwd(), "/data/", "statecmsdata.csv", sep ="")
write.csv(mppstate, file = file )
shiny::runApp()
setwd("C:/Users/Jare_2/Desktop/WorkDocs/CUNY/608/Final Project/my_app - Copy")
shiny::runApp()
getwd()
setwd(paste(getwd(), "/data/", sep=""))
load("cmsdata.RData")
shiny::runApp('C:/Users/Jare_2/Desktop/WorkDocs/CUNY/608/Final Project/my_app - Copy')
load("cmsdata.RData")
load("enrollees.RData")
load("medicare_payments.RData")
shiny::runApp('C:/Users/Jare_2/Desktop/WorkDocs/CUNY/608/Final Project/my_app - Copy')
enrollees2012
load("enrollees2012.RData")
enrollees2012
load("medicare_payments2012.RData")
getwd()
readloc = "/enrollees2012.csv"
enrollees2012 = read.csv(readloc)
save(enrollees2012, file = "enrollees2012.RData")
readloc = "/medicare_payments2012.csv"
medicare_payments2012 = read.csv(readloc)
save(medicare_payments2012, file = "medicare_payments2012.RData")
readloc = "/medicare_payments2012.csv"
medicare_payments2012 = read.csv(readloc)
readloc = "/medicare_payments2012.csv"
readloc
medicare_payments2012 = read.csv(readloc)
setwd(paste(getwd(), "/data/", sep=""))
getwd()
setwd("C:/Users/Jare_2/Desktop/WorkDocs/CUNY/608/Final Project/my_app - Copy")
getwd()
setwd(paste(getwd(), "/data/", sep=""))
readloc = "medicare_payments2012.csv"
medicare_payments2012 = read.csv(readloc)
save(medicare_payments2012, file = "medicare_payments2012.RData")
shiny::runApp('C:/Users/Jare_2/Desktop/WorkDocs/CUNY/608/Final Project/my_app - Copy')
load("cmsdata.RData")
load("enrollees2012.RData")
load("medicare_payments2012.RData")
type(cmsdata)
str(cmsdata)
mppstate = cmsdata %>%
group_by(state) %>%
summarise(Total_Payment = sum(total_medicare_payment_amt), Count = n()) %>%
arrange(desc(Total_Payment))
ampptype = cmsdata%>%
filter(gender == "M" | gender == "F") %>%
group_by(provider_type) %>%
summarise(Average_Payment = sum(total_medicare_payment_amt)/sum(total_unique_benes)) %>%
arrange(desc(Average_Payment))
mpprovider = cmsdata%>%
filter(gender == "M" | gender =="F") %>%
select(first_name, last_name, Specialty = provider_type, Total_Payment = total_medicare_payment_amt) %>%
arrange(desc(Total_Payment))
amppbene = cmsdata%>%
filter(gender == "M" | gender == "F") %>%
mutate(Average_Payment = total_medicare_payment_amt/total_unique_benes) %>%
select(first_name, last_name, Specialty = provider_type, Average_Payment, Total_Payment = total_medicare_payment_amt, total_unique_benes) %>%
arrange(desc(Average_Payment))
percapita = cmsdata%>%
filter(gender == "M" | gender == "F") %>%
group_by(state) %>%
summarise(statecap = sum(total_medicare_payment_amt)/mean(beneficiaries)) %>%
arrange(desc(statecap))
zip = cmsdata%>%
filter(gender == "M" | gender == "F") %>%
group_by(zip) %>%
summarise(total_payment = sum(total_medicare_payment_amt),
num_ben = sum(total_unique_benes), Average_Payment = (total_payment/num_ben)) %>%
arrange(desc(Average_Payment))
enrollees2012 = enrollees2012 %>%
arrange(desc(beneficiaries))
enrollees2012
readloc = "enrollees2012.csv"
enrollees2012 = read.csv(readloc)
save(enrollees2012, file = "enrollees2012.RData")
shiny::runApp('C:/Users/Jare_2/Desktop/WorkDocs/CUNY/608/Final Project/my_app - Copy')
shiny::runApp('C:/Users/Jare_2/Desktop/WorkDocs/CUNY/608/Final Project/my_app - Copy')
